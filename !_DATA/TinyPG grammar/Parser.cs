// Generated by TinyPG v1.3 available at www.codeproject.com

using System;
using System.Collections.Generic;

namespace Sharpen.Core.Parser
{
    #region Parser

    public partial class Parser 
    {
        private Scanner scanner;
        private ParseTree tree;
        
        public Parser(Scanner scanner)
        {
            this.scanner = scanner;
        }

        public ParseTree Parse(string input)
        {
            tree = new ParseTree();
            return Parse(input, tree);
        }

        public ParseTree Parse(string input, ParseTree tree)
        {
            scanner.Init(input);

            this.tree = tree;
            ParseStart(tree);
            tree.Skipped = scanner.Skipped;

            return tree;
        }

        private void ParseStart(ParseNode parent) // NonTerminalSymbol: Start
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Start), "Start");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.LookAhead(TokenType.USE); // Option Rule
            if (tok.Type == TokenType.USE)
            {
                ParseUseDirective(node); // NonTerminal Rule: UseDirective
            }

             // Concat Rule
            tok = scanner.LookAhead(TokenType.CLASS); // Option Rule
            if (tok.Type == TokenType.CLASS)
            {
                ParseClassDirective(node); // NonTerminal Rule: ClassDirective
            }

             // Concat Rule
            tok = scanner.LookAhead(TokenType.BASE); // Option Rule
            if (tok.Type == TokenType.BASE)
            {
                ParseBaseDirective(node); // NonTerminal Rule: BaseDirective
            }

             // Concat Rule
            tok = scanner.LookAhead(TokenType.OPTIONS); // Option Rule
            if (tok.Type == TokenType.OPTIONS)
            {
                ParseOptionsDirective(node); // NonTerminal Rule: OptionsDirective
            }

             // Concat Rule
            do { // OneOrMore Rule
                ParseFunctionDefinition(node); // NonTerminal Rule: FunctionDefinition
                tok = scanner.LookAhead(TokenType.AT); // OneOrMore Rule
            } while (tok.Type == TokenType.AT); // OneOrMore Rule

             // Concat Rule
            tok = scanner.Scan(TokenType.EOF); // Terminal Rule: EOF
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOF) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOF.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Start

        private void ParseUseDirective(ParseNode parent) // NonTerminalSymbol: UseDirective
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.UseDirective), "UseDirective");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.USE); // Terminal Rule: USE
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.USE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.USE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.IDENTIFIER); // Terminal Rule: IDENTIFIER
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IDENTIFIER) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

             // Concat Rule
            tok = scanner.LookAhead(TokenType.NL); // ZeroOrMore Rule
            while (tok.Type == TokenType.NL)
            {

                 // Concat Rule
                tok = scanner.Scan(TokenType.NL); // Terminal Rule: NL
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.NL) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NL.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }

                 // Concat Rule
                tok = scanner.Scan(TokenType.IDENTIFIER); // Terminal Rule: IDENTIFIER
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.IDENTIFIER) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }
            tok = scanner.LookAhead(TokenType.NL); // ZeroOrMore Rule
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: UseDirective

        private void ParseClassDirective(ParseNode parent) // NonTerminalSymbol: ClassDirective
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ClassDirective), "ClassDirective");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.CLASS); // Terminal Rule: CLASS
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.CLASS) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CLASS.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.NL); // Terminal Rule: NL
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.NL) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NL.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.IDENTIFIER); // Terminal Rule: IDENTIFIER
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IDENTIFIER) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: ClassDirective

        private void ParseBaseDirective(ParseNode parent) // NonTerminalSymbol: BaseDirective
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.BaseDirective), "BaseDirective");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.BASE); // Terminal Rule: BASE
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.BASE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BASE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.NL); // Terminal Rule: NL
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.NL) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NL.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.IDENTIFIER); // Terminal Rule: IDENTIFIER
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IDENTIFIER) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: BaseDirective

        private void ParseOptionsDirective(ParseNode parent) // NonTerminalSymbol: OptionsDirective
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.OptionsDirective), "OptionsDirective");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.OPTIONS); // Terminal Rule: OPTIONS
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.OPTIONS) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OPTIONS.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.IDENTIFIER); // Terminal Rule: IDENTIFIER
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IDENTIFIER) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

             // Concat Rule
            tok = scanner.LookAhead(TokenType.NL); // ZeroOrMore Rule
            while (tok.Type == TokenType.NL)
            {

                 // Concat Rule
                tok = scanner.Scan(TokenType.NL); // Terminal Rule: NL
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.NL) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NL.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }

                 // Concat Rule
                tok = scanner.Scan(TokenType.IDENTIFIER); // Terminal Rule: IDENTIFIER
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.IDENTIFIER) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }
            tok = scanner.LookAhead(TokenType.NL); // ZeroOrMore Rule
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: OptionsDirective

        private void ParseVariable(ParseNode parent) // NonTerminalSymbol: Variable
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Variable), "Variable");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.DOL); // Terminal Rule: DOL
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.DOL) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DOL.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.IDENTIFIER); // Terminal Rule: IDENTIFIER
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IDENTIFIER) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

             // Concat Rule
            tok = scanner.LookAhead(TokenType.DOT, TokenType.C); // ZeroOrMore Rule
            while (tok.Type == TokenType.DOT
                || tok.Type == TokenType.C)
            {

                 // Concat Rule
                tok = scanner.LookAhead(TokenType.DOT, TokenType.C); // Choice Rule
                switch (tok.Type)
                { // Choice Rule
                    case TokenType.DOT:
                        tok = scanner.Scan(TokenType.DOT); // Terminal Rule: DOT
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.DOT) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DOT.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                            return;
                        }
                        break;
                    case TokenType.C:
                        tok = scanner.Scan(TokenType.C); // Terminal Rule: C
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.C) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.C.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                            return;
                        }
                        break;
                    default:
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                        break;
                } // Choice Rule

                 // Concat Rule
                tok = scanner.LookAhead(TokenType.IDENTIFIER, TokenType.DOL); // Choice Rule
                switch (tok.Type)
                { // Choice Rule
                    case TokenType.IDENTIFIER:
                        ParseFieldName(node); // NonTerminal Rule: FieldName
                        break;
                    case TokenType.DOL:
                        ParseVariable(node); // NonTerminal Rule: Variable
                        break;
                    default:
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                        break;
                } // Choice Rule
            tok = scanner.LookAhead(TokenType.DOT, TokenType.C); // ZeroOrMore Rule
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Variable

        private void ParseFieldName(ParseNode parent) // NonTerminalSymbol: FieldName
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.FieldName), "FieldName");
            parent.Nodes.Add(node);

            tok = scanner.Scan(TokenType.IDENTIFIER); // Terminal Rule: IDENTIFIER
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IDENTIFIER) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: FieldName

        private void ParseLiteral(ParseNode parent) // NonTerminalSymbol: Literal
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Literal), "Literal");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.INTEGER, TokenType.DOUBLE, TokenType.STRING, TokenType.BOOLVALUE); // Choice Rule
            switch (tok.Type)
            { // Choice Rule
                case TokenType.INTEGER:
                    tok = scanner.Scan(TokenType.INTEGER); // Terminal Rule: INTEGER
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.INTEGER) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.INTEGER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.DOUBLE:
                    tok = scanner.Scan(TokenType.DOUBLE); // Terminal Rule: DOUBLE
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.DOUBLE) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DOUBLE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.STRING:
                    tok = scanner.Scan(TokenType.STRING); // Terminal Rule: STRING
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.STRING) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.STRING.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.BOOLVALUE:
                    tok = scanner.Scan(TokenType.BOOLVALUE); // Terminal Rule: BOOLVALUE
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.BOOLVALUE) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BOOLVALUE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            } // Choice Rule

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Literal

        private void ParseFunctionDefinition(ParseNode parent) // NonTerminalSymbol: FunctionDefinition
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.FunctionDefinition), "FunctionDefinition");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.AT); // Terminal Rule: AT
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.AT) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.AT.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

             // Concat Rule
            ParseFunctionName(node); // NonTerminal Rule: FunctionName

             // Concat Rule
            tok = scanner.Scan(TokenType.BRACKETOPEN); // Terminal Rule: BRACKETOPEN
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.BRACKETOPEN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRACKETOPEN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

             // Concat Rule
            tok = scanner.LookAhead(TokenType.IDENTIFIER); // Option Rule
            if (tok.Type == TokenType.IDENTIFIER)
            {
                ParseParamsDefinitions(node); // NonTerminal Rule: ParamsDefinitions
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.BRACKETCLOSE); // Terminal Rule: BRACKETCLOSE
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.BRACKETCLOSE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRACKETCLOSE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

             // Concat Rule
            tok = scanner.LookAhead(TokenType.BRACKETOPEN); // Option Rule
            if (tok.Type == TokenType.BRACKETOPEN)
            {
                ParseLocalVariables(node); // NonTerminal Rule: LocalVariables
            }

             // Concat Rule
            ParseBody(node); // NonTerminal Rule: Body

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: FunctionDefinition

        private void ParseFunctionName(ParseNode parent) // NonTerminalSymbol: FunctionName
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.FunctionName), "FunctionName");
            parent.Nodes.Add(node);

            tok = scanner.Scan(TokenType.IDENTIFIER); // Terminal Rule: IDENTIFIER
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IDENTIFIER) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: FunctionName

        private void ParseLocalVariables(ParseNode parent) // NonTerminalSymbol: LocalVariables
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.LocalVariables), "LocalVariables");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.BRACKETOPEN); // Terminal Rule: BRACKETOPEN
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.BRACKETOPEN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRACKETOPEN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

             // Concat Rule
            ParseVariablesDefinitions(node); // NonTerminal Rule: VariablesDefinitions

             // Concat Rule
            tok = scanner.Scan(TokenType.BRACKETCLOSE); // Terminal Rule: BRACKETCLOSE
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.BRACKETCLOSE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRACKETCLOSE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: LocalVariables

        private void ParseBody(ParseNode parent) // NonTerminalSymbol: Body
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Body), "Body");
            parent.Nodes.Add(node);

            do { // OneOrMore Rule
                tok = scanner.LookAhead(TokenType.CF, TokenType.DOL, TokenType.PLAIN); // Choice Rule
                switch (tok.Type)
                { // Choice Rule
                    case TokenType.CF:
                        ParseCall(node); // NonTerminal Rule: Call
                        break;
                    case TokenType.DOL:

                         // Concat Rule
                        ParseVariable(node); // NonTerminal Rule: Variable

                         // Concat Rule
                        tok = scanner.LookAhead(TokenType.BRACKETOPEN, TokenType.PARENOPEN); // Option Rule
                        if (tok.Type == TokenType.BRACKETOPEN
                            || tok.Type == TokenType.PARENOPEN)
                        {
                            ParseAssignment(node); // NonTerminal Rule: Assignment
                        }
                        break;
                    case TokenType.PLAIN:
                        tok = scanner.Scan(TokenType.PLAIN); // Terminal Rule: PLAIN
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.PLAIN) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PLAIN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                            return;
                        }
                        break;
                    default:
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                        break;
                } // Choice Rule
                tok = scanner.LookAhead(TokenType.CF, TokenType.DOL, TokenType.PLAIN); // OneOrMore Rule
            } while (tok.Type == TokenType.CF
                || tok.Type == TokenType.DOL
                || tok.Type == TokenType.PLAIN); // OneOrMore Rule

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Body

        private void ParseCall(ParseNode parent) // NonTerminalSymbol: Call
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Call), "Call");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.CF); // Terminal Rule: CF
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.CF) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CF.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

             // Concat Rule
            tok = scanner.LookAhead(TokenType.EVAL, TokenType.WHILE, TokenType.IDENTIFIER, TokenType.FOR, TokenType.IF); // Choice Rule
            switch (tok.Type)
            { // Choice Rule
                case TokenType.EVAL:
                    ParseEvalConstruct(node); // NonTerminal Rule: EvalConstruct
                    break;
                case TokenType.WHILE:
                    ParseWhileCycle(node); // NonTerminal Rule: WhileCycle
                    break;
                case TokenType.IDENTIFIER:
                    ParseFunction(node); // NonTerminal Rule: Function
                    break;
                case TokenType.FOR:
                    ParseForCycle(node); // NonTerminal Rule: ForCycle
                    break;
                case TokenType.IF:
                    ParseIfCondition(node); // NonTerminal Rule: IfCondition
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            } // Choice Rule

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Call

        private void ParseFunction(ParseNode parent) // NonTerminalSymbol: Function
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Function), "Function");
            parent.Nodes.Add(node);


             // Concat Rule
            ParseFullFunctionName(node); // NonTerminal Rule: FullFunctionName

             // Concat Rule
            tok = scanner.LookAhead(TokenType.BRACKETOPEN, TokenType.PARENOPEN); // Choice Rule
            switch (tok.Type)
            { // Choice Rule
                case TokenType.BRACKETOPEN:
                    tok = scanner.Scan(TokenType.BRACKETOPEN); // Terminal Rule: BRACKETOPEN
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.BRACKETOPEN) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRACKETOPEN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.PARENOPEN:
                    tok = scanner.Scan(TokenType.PARENOPEN); // Terminal Rule: PARENOPEN
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.PARENOPEN) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PARENOPEN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            } // Choice Rule

             // Concat Rule
            tok = scanner.LookAhead(TokenType.INTEGER, TokenType.DOUBLE, TokenType.STRING, TokenType.CF, TokenType.DOLDOT); // Option Rule
            if (tok.Type == TokenType.INTEGER
                || tok.Type == TokenType.DOUBLE
                || tok.Type == TokenType.STRING
                || tok.Type == TokenType.CF
                || tok.Type == TokenType.DOLDOT)
            {
                ParseParams(node); // NonTerminal Rule: Params
            }

             // Concat Rule
            tok = scanner.LookAhead(TokenType.BRACKETCLOSE, TokenType.PARENCLOSE); // Choice Rule
            switch (tok.Type)
            { // Choice Rule
                case TokenType.BRACKETCLOSE:
                    tok = scanner.Scan(TokenType.BRACKETCLOSE); // Terminal Rule: BRACKETCLOSE
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.BRACKETCLOSE) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRACKETCLOSE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.PARENCLOSE:
                    tok = scanner.Scan(TokenType.PARENCLOSE); // Terminal Rule: PARENCLOSE
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.PARENCLOSE) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PARENCLOSE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            } // Choice Rule

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Function

        private void ParseFullFunctionName(ParseNode parent) // NonTerminalSymbol: FullFunctionName
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.FullFunctionName), "FullFunctionName");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.IDENTIFIER); // Terminal Rule: IDENTIFIER
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IDENTIFIER) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

             // Concat Rule
            tok = scanner.LookAhead(TokenType.C, TokenType.DOT, TokenType.CC); // Option Rule
            if (tok.Type == TokenType.C
                || tok.Type == TokenType.DOT
                || tok.Type == TokenType.CC)
            {

                 // Concat Rule
                tok = scanner.LookAhead(TokenType.C, TokenType.DOT, TokenType.CC); // Choice Rule
                switch (tok.Type)
                { // Choice Rule
                    case TokenType.C:
                        ParseStaticPrefix(node); // NonTerminal Rule: StaticPrefix
                        break;
                    case TokenType.DOT:
                        ParseInstancePrefix(node); // NonTerminal Rule: InstancePrefix
                        break;
                    case TokenType.CC:
                        ParseConstructorPrefix(node); // NonTerminal Rule: ConstructorPrefix
                        break;
                    default:
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                        break;
                } // Choice Rule

                 // Concat Rule
                tok = scanner.Scan(TokenType.IDENTIFIER); // Terminal Rule: IDENTIFIER
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.IDENTIFIER) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: FullFunctionName

        private void ParseStaticPrefix(ParseNode parent) // NonTerminalSymbol: StaticPrefix
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.StaticPrefix), "StaticPrefix");
            parent.Nodes.Add(node);

            tok = scanner.Scan(TokenType.C); // Terminal Rule: C
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.C) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.C.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: StaticPrefix

        private void ParseInstancePrefix(ParseNode parent) // NonTerminalSymbol: InstancePrefix
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.InstancePrefix), "InstancePrefix");
            parent.Nodes.Add(node);

            tok = scanner.Scan(TokenType.DOT); // Terminal Rule: DOT
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.DOT) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DOT.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: InstancePrefix

        private void ParseConstructorPrefix(ParseNode parent) // NonTerminalSymbol: ConstructorPrefix
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ConstructorPrefix), "ConstructorPrefix");
            parent.Nodes.Add(node);

            tok = scanner.Scan(TokenType.CC); // Terminal Rule: CC
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.CC) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CC.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: ConstructorPrefix

        private void ParseEvalConstruct(ParseNode parent) // NonTerminalSymbol: EvalConstruct
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.EvalConstruct), "EvalConstruct");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.EVAL); // Terminal Rule: EVAL
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EVAL) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EVAL.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.PARENOPEN); // Terminal Rule: PARENOPEN
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.PARENOPEN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PARENOPEN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

             // Concat Rule
            ParseEvalBody(node); // NonTerminal Rule: EvalBody

             // Concat Rule
            tok = scanner.Scan(TokenType.PARENCLOSE); // Terminal Rule: PARENCLOSE
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.PARENCLOSE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PARENCLOSE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

             // Concat Rule
            tok = scanner.LookAhead(TokenType.BRACKETOPEN); // Option Rule
            if (tok.Type == TokenType.BRACKETOPEN)
            {

                 // Concat Rule
                tok = scanner.Scan(TokenType.BRACKETOPEN); // Terminal Rule: BRACKETOPEN
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.BRACKETOPEN) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRACKETOPEN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }

                 // Concat Rule
                ParseFormatString(node); // NonTerminal Rule: FormatString

                 // Concat Rule
                tok = scanner.Scan(TokenType.BRACKETCLOSE); // Terminal Rule: BRACKETCLOSE
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.BRACKETCLOSE) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRACKETCLOSE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: EvalConstruct

        private void ParseEvalBody(ParseNode parent) // NonTerminalSymbol: EvalBody
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.EvalBody), "EvalBody");
            parent.Nodes.Add(node);

            tok = scanner.Scan(TokenType.STRING); // Terminal Rule: STRING
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.STRING) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.STRING.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: EvalBody

        private void ParseFormatString(ParseNode parent) // NonTerminalSymbol: FormatString
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.FormatString), "FormatString");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.PERCENT); // Terminal Rule: PERCENT
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.PERCENT) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PERCENT.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.STRING); // Terminal Rule: STRING
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.STRING) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.STRING.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: FormatString

        private void ParseWhileCycle(ParseNode parent) // NonTerminalSymbol: WhileCycle
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.WhileCycle), "WhileCycle");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.WHILE); // Terminal Rule: WHILE
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.WHILE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.WHILE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

             // Concat Rule
            ParseWhileCondition(node); // NonTerminal Rule: WhileCondition

             // Concat Rule
            ParseWhileBody(node); // NonTerminal Rule: WhileBody

             // Concat Rule
            tok = scanner.LookAhead(TokenType.BRACKETOPEN, TokenType.CURLYOPEN); // Option Rule
            if (tok.Type == TokenType.BRACKETOPEN
                || tok.Type == TokenType.CURLYOPEN)
            {
                ParseCycleSeparator(node); // NonTerminal Rule: CycleSeparator
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: WhileCycle

        private void ParseWhileCondition(ParseNode parent) // NonTerminalSymbol: WhileCondition
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.WhileCondition), "WhileCondition");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.PARENOPEN); // Terminal Rule: PARENOPEN
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.PARENOPEN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PARENOPEN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

             // Concat Rule
            ParseBoolCondition(node); // NonTerminal Rule: BoolCondition

             // Concat Rule
            tok = scanner.Scan(TokenType.PARENCLOSE); // Terminal Rule: PARENCLOSE
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.PARENCLOSE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PARENCLOSE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: WhileCondition

        private void ParseWhileBody(ParseNode parent) // NonTerminalSymbol: WhileBody
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.WhileBody), "WhileBody");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.CURLYOPEN); // Terminal Rule: CURLYOPEN
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.CURLYOPEN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CURLYOPEN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

             // Concat Rule
            ParseBody(node); // NonTerminal Rule: Body

             // Concat Rule
            tok = scanner.Scan(TokenType.CURLYCLOSE); // Terminal Rule: CURLYCLOSE
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.CURLYCLOSE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CURLYCLOSE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: WhileBody

        private void ParseCycleSeparator(ParseNode parent) // NonTerminalSymbol: CycleSeparator
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.CycleSeparator), "CycleSeparator");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.LookAhead(TokenType.BRACKETOPEN, TokenType.CURLYOPEN); // Choice Rule
            switch (tok.Type)
            { // Choice Rule
                case TokenType.BRACKETOPEN:
                    tok = scanner.Scan(TokenType.BRACKETOPEN); // Terminal Rule: BRACKETOPEN
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.BRACKETOPEN) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRACKETOPEN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.CURLYOPEN:
                    tok = scanner.Scan(TokenType.CURLYOPEN); // Terminal Rule: CURLYOPEN
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.CURLYOPEN) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CURLYOPEN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            } // Choice Rule

             // Concat Rule
            ParseBody(node); // NonTerminal Rule: Body

             // Concat Rule
            tok = scanner.LookAhead(TokenType.BRACKETCLOSE, TokenType.CURLYCLOSE); // Choice Rule
            switch (tok.Type)
            { // Choice Rule
                case TokenType.BRACKETCLOSE:
                    tok = scanner.Scan(TokenType.BRACKETCLOSE); // Terminal Rule: BRACKETCLOSE
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.BRACKETCLOSE) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRACKETCLOSE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.CURLYCLOSE:
                    tok = scanner.Scan(TokenType.CURLYCLOSE); // Terminal Rule: CURLYCLOSE
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.CURLYCLOSE) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CURLYCLOSE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            } // Choice Rule

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: CycleSeparator

        private void ParseBoolCondition(ParseNode parent) // NonTerminalSymbol: BoolCondition
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.BoolCondition), "BoolCondition");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.DOL, TokenType.CF, TokenType.BOOLVALUE, TokenType.NOT, TokenType.DEF, TokenType.FILEEXISTS, TokenType.DIRECTORYEXISTS); // Choice Rule
            switch (tok.Type)
            { // Choice Rule
                case TokenType.DOL:

                     // Concat Rule
                    ParseVariable(node); // NonTerminal Rule: Variable

                     // Concat Rule
                    tok = scanner.LookAhead(TokenType.NOT); // Option Rule
                    if (tok.Type == TokenType.NOT)
                    {
                        tok = scanner.Scan(TokenType.NOT); // Terminal Rule: NOT
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.NOT) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NOT.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                            return;
                        }
                    }

                     // Concat Rule
                    tok = scanner.LookAhead(TokenType.EQ, TokenType.NE, TokenType.GT, TokenType.LT, TokenType.IS, TokenType.IN, TokenType.SEQ, TokenType.SNE, TokenType.SGT, TokenType.SLT); // Choice Rule
                    switch (tok.Type)
                    { // Choice Rule
                        case TokenType.EQ:
                            tok = scanner.Scan(TokenType.EQ); // Terminal Rule: EQ
                            n = node.CreateNode(tok, tok.ToString() );
                            node.Token.UpdateRange(tok);
                            node.Nodes.Add(n);
                            if (tok.Type != TokenType.EQ) {
                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EQ.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                                return;
                            }
                            break;
                        case TokenType.NE:
                            tok = scanner.Scan(TokenType.NE); // Terminal Rule: NE
                            n = node.CreateNode(tok, tok.ToString() );
                            node.Token.UpdateRange(tok);
                            node.Nodes.Add(n);
                            if (tok.Type != TokenType.NE) {
                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                                return;
                            }
                            break;
                        case TokenType.GT:
                            tok = scanner.Scan(TokenType.GT); // Terminal Rule: GT
                            n = node.CreateNode(tok, tok.ToString() );
                            node.Token.UpdateRange(tok);
                            node.Nodes.Add(n);
                            if (tok.Type != TokenType.GT) {
                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.GT.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                                return;
                            }
                            break;
                        case TokenType.LT:
                            tok = scanner.Scan(TokenType.LT); // Terminal Rule: LT
                            n = node.CreateNode(tok, tok.ToString() );
                            node.Token.UpdateRange(tok);
                            node.Nodes.Add(n);
                            if (tok.Type != TokenType.LT) {
                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.LT.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                                return;
                            }
                            break;
                        case TokenType.IS:
                            tok = scanner.Scan(TokenType.IS); // Terminal Rule: IS
                            n = node.CreateNode(tok, tok.ToString() );
                            node.Token.UpdateRange(tok);
                            node.Nodes.Add(n);
                            if (tok.Type != TokenType.IS) {
                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IS.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                                return;
                            }
                            break;
                        case TokenType.IN:
                            tok = scanner.Scan(TokenType.IN); // Terminal Rule: IN
                            n = node.CreateNode(tok, tok.ToString() );
                            node.Token.UpdateRange(tok);
                            node.Nodes.Add(n);
                            if (tok.Type != TokenType.IN) {
                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                                return;
                            }
                            break;
                        case TokenType.SEQ:
                            tok = scanner.Scan(TokenType.SEQ); // Terminal Rule: SEQ
                            n = node.CreateNode(tok, tok.ToString() );
                            node.Token.UpdateRange(tok);
                            node.Nodes.Add(n);
                            if (tok.Type != TokenType.SEQ) {
                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SEQ.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                                return;
                            }
                            break;
                        case TokenType.SNE:
                            tok = scanner.Scan(TokenType.SNE); // Terminal Rule: SNE
                            n = node.CreateNode(tok, tok.ToString() );
                            node.Token.UpdateRange(tok);
                            node.Nodes.Add(n);
                            if (tok.Type != TokenType.SNE) {
                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SNE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                                return;
                            }
                            break;
                        case TokenType.SGT:
                            tok = scanner.Scan(TokenType.SGT); // Terminal Rule: SGT
                            n = node.CreateNode(tok, tok.ToString() );
                            node.Token.UpdateRange(tok);
                            node.Nodes.Add(n);
                            if (tok.Type != TokenType.SGT) {
                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SGT.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                                return;
                            }
                            break;
                        case TokenType.SLT:
                            tok = scanner.Scan(TokenType.SLT); // Terminal Rule: SLT
                            n = node.CreateNode(tok, tok.ToString() );
                            node.Token.UpdateRange(tok);
                            node.Nodes.Add(n);
                            if (tok.Type != TokenType.SLT) {
                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SLT.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                                return;
                            }
                            break;
                        default:
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                            break;
                    } // Choice Rule

                     // Concat Rule
                    tok = scanner.LookAhead(TokenType.DOL, TokenType.INTEGER, TokenType.DOUBLE, TokenType.STRING, TokenType.BOOLVALUE); // Choice Rule
                    switch (tok.Type)
                    { // Choice Rule
                        case TokenType.DOL:
                            ParseVariable(node); // NonTerminal Rule: Variable
                            break;
                        case TokenType.INTEGER:
                        case TokenType.DOUBLE:
                        case TokenType.STRING:
                        case TokenType.BOOLVALUE:
                            ParseLiteral(node); // NonTerminal Rule: Literal
                            break;
                        default:
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                            break;
                    } // Choice Rule
                    break;
                case TokenType.CF:

                     // Concat Rule
                    tok = scanner.Scan(TokenType.CF); // Terminal Rule: CF
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.CF) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CF.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }

                     // Concat Rule
                    ParseFunction(node); // NonTerminal Rule: Function
                    break;
                case TokenType.BOOLVALUE:
                    tok = scanner.Scan(TokenType.BOOLVALUE); // Terminal Rule: BOOLVALUE
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.BOOLVALUE) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BOOLVALUE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.NOT:
                case TokenType.DEF:

                     // Concat Rule
                    tok = scanner.LookAhead(TokenType.NOT); // Option Rule
                    if (tok.Type == TokenType.NOT)
                    {
                        tok = scanner.Scan(TokenType.NOT); // Terminal Rule: NOT
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.NOT) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NOT.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                            return;
                        }
                    }

                     // Concat Rule
                    tok = scanner.Scan(TokenType.DEF); // Terminal Rule: DEF
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.DEF) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DEF.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }

                     // Concat Rule
                    ParseVariable(node); // NonTerminal Rule: Variable
                    break;
                case TokenType.FILEEXISTS:

                     // Concat Rule
                    tok = scanner.Scan(TokenType.FILEEXISTS); // Terminal Rule: FILEEXISTS
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.FILEEXISTS) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FILEEXISTS.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }

                     // Concat Rule
                    tok = scanner.LookAhead(TokenType.DOL, TokenType.STRING); // Choice Rule
                    switch (tok.Type)
                    { // Choice Rule
                        case TokenType.DOL:
                            ParseVariable(node); // NonTerminal Rule: Variable
                            break;
                        case TokenType.STRING:
                            tok = scanner.Scan(TokenType.STRING); // Terminal Rule: STRING
                            n = node.CreateNode(tok, tok.ToString() );
                            node.Token.UpdateRange(tok);
                            node.Nodes.Add(n);
                            if (tok.Type != TokenType.STRING) {
                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.STRING.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                                return;
                            }
                            break;
                        default:
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                            break;
                    } // Choice Rule
                    break;
                case TokenType.DIRECTORYEXISTS:

                     // Concat Rule
                    tok = scanner.Scan(TokenType.DIRECTORYEXISTS); // Terminal Rule: DIRECTORYEXISTS
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.DIRECTORYEXISTS) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DIRECTORYEXISTS.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }

                     // Concat Rule
                    tok = scanner.LookAhead(TokenType.DOL, TokenType.STRING); // Choice Rule
                    switch (tok.Type)
                    { // Choice Rule
                        case TokenType.DOL:
                            ParseVariable(node); // NonTerminal Rule: Variable
                            break;
                        case TokenType.STRING:
                            tok = scanner.Scan(TokenType.STRING); // Terminal Rule: STRING
                            n = node.CreateNode(tok, tok.ToString() );
                            node.Token.UpdateRange(tok);
                            node.Nodes.Add(n);
                            if (tok.Type != TokenType.STRING) {
                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.STRING.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                                return;
                            }
                            break;
                        default:
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                            break;
                    } // Choice Rule
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            } // Choice Rule

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: BoolCondition

        private void ParseForCycle(ParseNode parent) // NonTerminalSymbol: ForCycle
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ForCycle), "ForCycle");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.FOR); // Terminal Rule: FOR
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.FOR) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOR.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

             // Concat Rule
            ParseForCounter(node); // NonTerminal Rule: ForCounter

             // Concat Rule
            tok = scanner.Scan(TokenType.PARENOPEN); // Terminal Rule: PARENOPEN
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.PARENOPEN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PARENOPEN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

             // Concat Rule
            ParseForFrom(node); // NonTerminal Rule: ForFrom

             // Concat Rule
            tok = scanner.Scan(TokenType.SC); // Terminal Rule: SC
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.SC) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SC.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

             // Concat Rule
            ParseForTo(node); // NonTerminal Rule: ForTo

             // Concat Rule
            tok = scanner.Scan(TokenType.PARENCLOSE); // Terminal Rule: PARENCLOSE
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.PARENCLOSE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PARENCLOSE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

             // Concat Rule
            ParseForBody(node); // NonTerminal Rule: ForBody

             // Concat Rule
            tok = scanner.LookAhead(TokenType.BRACKETOPEN, TokenType.CURLYOPEN); // Option Rule
            if (tok.Type == TokenType.BRACKETOPEN
                || tok.Type == TokenType.CURLYOPEN)
            {
                ParseCycleSeparator(node); // NonTerminal Rule: CycleSeparator
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: ForCycle

        private void ParseForCounter(ParseNode parent) // NonTerminalSymbol: ForCounter
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ForCounter), "ForCounter");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.BRACKETOPEN); // Terminal Rule: BRACKETOPEN
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.BRACKETOPEN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRACKETOPEN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

             // Concat Rule
            ParseVariable(node); // NonTerminal Rule: Variable

             // Concat Rule
            tok = scanner.Scan(TokenType.BRACKETCLOSE); // Terminal Rule: BRACKETCLOSE
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.BRACKETCLOSE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRACKETCLOSE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: ForCounter

        private void ParseForFrom(ParseNode parent) // NonTerminalSymbol: ForFrom
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ForFrom), "ForFrom");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.INTEGER, TokenType.CF, TokenType.DOL); // Choice Rule
            switch (tok.Type)
            { // Choice Rule
                case TokenType.INTEGER:
                    tok = scanner.Scan(TokenType.INTEGER); // Terminal Rule: INTEGER
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.INTEGER) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.INTEGER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.CF:

                     // Concat Rule
                    tok = scanner.Scan(TokenType.CF); // Terminal Rule: CF
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.CF) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CF.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }

                     // Concat Rule
                    ParseFunction(node); // NonTerminal Rule: Function
                    break;
                case TokenType.DOL:
                    ParseVariable(node); // NonTerminal Rule: Variable
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            } // Choice Rule

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: ForFrom

        private void ParseForTo(ParseNode parent) // NonTerminalSymbol: ForTo
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ForTo), "ForTo");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.INTEGER, TokenType.CF, TokenType.DOL); // Choice Rule
            switch (tok.Type)
            { // Choice Rule
                case TokenType.INTEGER:
                    tok = scanner.Scan(TokenType.INTEGER); // Terminal Rule: INTEGER
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.INTEGER) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.INTEGER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.CF:

                     // Concat Rule
                    tok = scanner.Scan(TokenType.CF); // Terminal Rule: CF
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.CF) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CF.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }

                     // Concat Rule
                    ParseFunction(node); // NonTerminal Rule: Function
                    break;
                case TokenType.DOL:
                    ParseVariable(node); // NonTerminal Rule: Variable
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            } // Choice Rule

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: ForTo

        private void ParseForBody(ParseNode parent) // NonTerminalSymbol: ForBody
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ForBody), "ForBody");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.CURLYOPEN); // Terminal Rule: CURLYOPEN
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.CURLYOPEN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CURLYOPEN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

             // Concat Rule
            ParseBody(node); // NonTerminal Rule: Body

             // Concat Rule
            tok = scanner.Scan(TokenType.CURLYCLOSE); // Terminal Rule: CURLYCLOSE
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.CURLYCLOSE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CURLYCLOSE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: ForBody

        private void ParseIfCondition(ParseNode parent) // NonTerminalSymbol: IfCondition
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.IfCondition), "IfCondition");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.IF); // Terminal Rule: IF
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IF) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IF.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.PARENOPEN); // Terminal Rule: PARENOPEN
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.PARENOPEN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PARENOPEN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

             // Concat Rule
            ParseBoolCondition(node); // NonTerminal Rule: BoolCondition

             // Concat Rule
            tok = scanner.Scan(TokenType.PARENCLOSE); // Terminal Rule: PARENCLOSE
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.PARENCLOSE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PARENCLOSE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

             // Concat Rule
            ParseIfTrueBranch(node); // NonTerminal Rule: IfTrueBranch

             // Concat Rule
            tok = scanner.LookAhead(TokenType.CURLYOPEN); // Option Rule
            if (tok.Type == TokenType.CURLYOPEN)
            {
                ParseIfFalseBranch(node); // NonTerminal Rule: IfFalseBranch
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: IfCondition

        private void ParseIfTrueBranch(ParseNode parent) // NonTerminalSymbol: IfTrueBranch
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.IfTrueBranch), "IfTrueBranch");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.CURLYOPEN); // Terminal Rule: CURLYOPEN
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.CURLYOPEN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CURLYOPEN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

             // Concat Rule
            ParseBody(node); // NonTerminal Rule: Body

             // Concat Rule
            tok = scanner.Scan(TokenType.CURLYCLOSE); // Terminal Rule: CURLYCLOSE
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.CURLYCLOSE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CURLYCLOSE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: IfTrueBranch

        private void ParseIfFalseBranch(ParseNode parent) // NonTerminalSymbol: IfFalseBranch
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.IfFalseBranch), "IfFalseBranch");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.CURLYOPEN); // Terminal Rule: CURLYOPEN
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.CURLYOPEN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CURLYOPEN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

             // Concat Rule
            ParseBody(node); // NonTerminal Rule: Body

             // Concat Rule
            tok = scanner.Scan(TokenType.CURLYCLOSE); // Terminal Rule: CURLYCLOSE
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.CURLYCLOSE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CURLYCLOSE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: IfFalseBranch

        private void ParseAssignment(ParseNode parent) // NonTerminalSymbol: Assignment
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Assignment), "Assignment");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.LookAhead(TokenType.BRACKETOPEN, TokenType.PARENOPEN); // Choice Rule
            switch (tok.Type)
            { // Choice Rule
                case TokenType.BRACKETOPEN:
                    tok = scanner.Scan(TokenType.BRACKETOPEN); // Terminal Rule: BRACKETOPEN
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.BRACKETOPEN) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRACKETOPEN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.PARENOPEN:
                    tok = scanner.Scan(TokenType.PARENOPEN); // Terminal Rule: PARENOPEN
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.PARENOPEN) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PARENOPEN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            } // Choice Rule

             // Concat Rule
            ParseAssignmentBody(node); // NonTerminal Rule: AssignmentBody

             // Concat Rule
            tok = scanner.LookAhead(TokenType.BRACKETCLOSE, TokenType.PARENCLOSE); // Choice Rule
            switch (tok.Type)
            { // Choice Rule
                case TokenType.BRACKETCLOSE:
                    tok = scanner.Scan(TokenType.BRACKETCLOSE); // Terminal Rule: BRACKETCLOSE
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.BRACKETCLOSE) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRACKETCLOSE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.PARENCLOSE:
                    tok = scanner.Scan(TokenType.PARENCLOSE); // Terminal Rule: PARENCLOSE
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.PARENCLOSE) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PARENCLOSE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            } // Choice Rule

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Assignment

        private void ParseAssignmentBody(ParseNode parent) // NonTerminalSymbol: AssignmentBody
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.AssignmentBody), "AssignmentBody");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.INTEGER, TokenType.DOUBLE, TokenType.STRING, TokenType.CF, TokenType.DOL, TokenType.BOOLVALUE, TokenType.DOLDOT); // Choice Rule
            switch (tok.Type)
            { // Choice Rule
                case TokenType.INTEGER:
                case TokenType.DOUBLE:
                case TokenType.STRING:
                case TokenType.CF:
                case TokenType.DOL:

                     // Concat Rule
                    tok = scanner.LookAhead(TokenType.INTEGER, TokenType.DOUBLE, TokenType.STRING, TokenType.CF, TokenType.DOL); // Choice Rule
                    switch (tok.Type)
                    { // Choice Rule
                        case TokenType.INTEGER:
                            tok = scanner.Scan(TokenType.INTEGER); // Terminal Rule: INTEGER
                            n = node.CreateNode(tok, tok.ToString() );
                            node.Token.UpdateRange(tok);
                            node.Nodes.Add(n);
                            if (tok.Type != TokenType.INTEGER) {
                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.INTEGER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                                return;
                            }
                            break;
                        case TokenType.DOUBLE:
                            tok = scanner.Scan(TokenType.DOUBLE); // Terminal Rule: DOUBLE
                            n = node.CreateNode(tok, tok.ToString() );
                            node.Token.UpdateRange(tok);
                            node.Nodes.Add(n);
                            if (tok.Type != TokenType.DOUBLE) {
                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DOUBLE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                                return;
                            }
                            break;
                        case TokenType.STRING:
                            tok = scanner.Scan(TokenType.STRING); // Terminal Rule: STRING
                            n = node.CreateNode(tok, tok.ToString() );
                            node.Token.UpdateRange(tok);
                            node.Nodes.Add(n);
                            if (tok.Type != TokenType.STRING) {
                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.STRING.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                                return;
                            }
                            break;
                        case TokenType.CF:

                             // Concat Rule
                            tok = scanner.Scan(TokenType.CF); // Terminal Rule: CF
                            n = node.CreateNode(tok, tok.ToString() );
                            node.Token.UpdateRange(tok);
                            node.Nodes.Add(n);
                            if (tok.Type != TokenType.CF) {
                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CF.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                                return;
                            }

                             // Concat Rule
                            ParseFunction(node); // NonTerminal Rule: Function
                            break;
                        case TokenType.DOL:
                            ParseVariable(node); // NonTerminal Rule: Variable
                            break;
                        default:
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                            break;
                    } // Choice Rule

                     // Concat Rule
                    tok = scanner.LookAhead(TokenType.PLUS, TokenType.MINUS, TokenType.MUL, TokenType.DIV); // ZeroOrMore Rule
                    while (tok.Type == TokenType.PLUS
                        || tok.Type == TokenType.MINUS
                        || tok.Type == TokenType.MUL
                        || tok.Type == TokenType.DIV)
                    {

                         // Concat Rule
                        ParseMathOp(node); // NonTerminal Rule: MathOp

                         // Concat Rule
                        tok = scanner.LookAhead(TokenType.INTEGER, TokenType.DOUBLE, TokenType.STRING, TokenType.CF, TokenType.DOL); // Choice Rule
                        switch (tok.Type)
                        { // Choice Rule
                            case TokenType.INTEGER:
                                tok = scanner.Scan(TokenType.INTEGER); // Terminal Rule: INTEGER
                                n = node.CreateNode(tok, tok.ToString() );
                                node.Token.UpdateRange(tok);
                                node.Nodes.Add(n);
                                if (tok.Type != TokenType.INTEGER) {
                                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.INTEGER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                                    return;
                                }
                                break;
                            case TokenType.DOUBLE:
                                tok = scanner.Scan(TokenType.DOUBLE); // Terminal Rule: DOUBLE
                                n = node.CreateNode(tok, tok.ToString() );
                                node.Token.UpdateRange(tok);
                                node.Nodes.Add(n);
                                if (tok.Type != TokenType.DOUBLE) {
                                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DOUBLE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                                    return;
                                }
                                break;
                            case TokenType.STRING:
                                tok = scanner.Scan(TokenType.STRING); // Terminal Rule: STRING
                                n = node.CreateNode(tok, tok.ToString() );
                                node.Token.UpdateRange(tok);
                                node.Nodes.Add(n);
                                if (tok.Type != TokenType.STRING) {
                                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.STRING.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                                    return;
                                }
                                break;
                            case TokenType.CF:

                                 // Concat Rule
                                tok = scanner.Scan(TokenType.CF); // Terminal Rule: CF
                                n = node.CreateNode(tok, tok.ToString() );
                                node.Token.UpdateRange(tok);
                                node.Nodes.Add(n);
                                if (tok.Type != TokenType.CF) {
                                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CF.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                                    return;
                                }

                                 // Concat Rule
                                ParseFunction(node); // NonTerminal Rule: Function
                                break;
                            case TokenType.DOL:
                                ParseVariable(node); // NonTerminal Rule: Variable
                                break;
                            default:
                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                                break;
                        } // Choice Rule
                    tok = scanner.LookAhead(TokenType.PLUS, TokenType.MINUS, TokenType.MUL, TokenType.DIV); // ZeroOrMore Rule
                    }
                    break;
                case TokenType.BOOLVALUE:
                    tok = scanner.Scan(TokenType.BOOLVALUE); // Terminal Rule: BOOLVALUE
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.BOOLVALUE) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BOOLVALUE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.DOLDOT:
                    do { // OneOrMore Rule
                        ParseHashAssignment(node); // NonTerminal Rule: HashAssignment
                        tok = scanner.LookAhead(TokenType.DOLDOT); // OneOrMore Rule
                    } while (tok.Type == TokenType.DOLDOT); // OneOrMore Rule
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            } // Choice Rule

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: AssignmentBody

        private void ParseMathOp(ParseNode parent) // NonTerminalSymbol: MathOp
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.MathOp), "MathOp");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.PLUS, TokenType.MINUS, TokenType.MUL, TokenType.DIV); // Choice Rule
            switch (tok.Type)
            { // Choice Rule
                case TokenType.PLUS:
                    tok = scanner.Scan(TokenType.PLUS); // Terminal Rule: PLUS
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.PLUS) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PLUS.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.MINUS:
                    tok = scanner.Scan(TokenType.MINUS); // Terminal Rule: MINUS
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.MINUS) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MINUS.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.MUL:
                    tok = scanner.Scan(TokenType.MUL); // Terminal Rule: MUL
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.MUL) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MUL.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.DIV:
                    tok = scanner.Scan(TokenType.DIV); // Terminal Rule: DIV
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.DIV) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DIV.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            } // Choice Rule

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: MathOp

        private void ParseHashAssignment(ParseNode parent) // NonTerminalSymbol: HashAssignment
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.HashAssignment), "HashAssignment");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.DOLDOT); // Terminal Rule: DOLDOT
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.DOLDOT) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DOLDOT.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

             // Concat Rule
            ParseKey(node); // NonTerminal Rule: Key

             // Concat Rule
            tok = scanner.LookAhead(TokenType.BRACKETOPEN, TokenType.PARENOPEN); // Choice Rule
            switch (tok.Type)
            { // Choice Rule
                case TokenType.BRACKETOPEN:
                    tok = scanner.Scan(TokenType.BRACKETOPEN); // Terminal Rule: BRACKETOPEN
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.BRACKETOPEN) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRACKETOPEN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.PARENOPEN:
                    tok = scanner.Scan(TokenType.PARENOPEN); // Terminal Rule: PARENOPEN
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.PARENOPEN) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PARENOPEN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            } // Choice Rule

             // Concat Rule
            ParseAssignmentBody(node); // NonTerminal Rule: AssignmentBody

             // Concat Rule
            tok = scanner.LookAhead(TokenType.BRACKETCLOSE, TokenType.PARENCLOSE); // Choice Rule
            switch (tok.Type)
            { // Choice Rule
                case TokenType.BRACKETCLOSE:
                    tok = scanner.Scan(TokenType.BRACKETCLOSE); // Terminal Rule: BRACKETCLOSE
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.BRACKETCLOSE) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRACKETCLOSE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.PARENCLOSE:
                    tok = scanner.Scan(TokenType.PARENCLOSE); // Terminal Rule: PARENCLOSE
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.PARENCLOSE) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PARENCLOSE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            } // Choice Rule

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: HashAssignment

        private void ParseKey(ParseNode parent) // NonTerminalSymbol: Key
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Key), "Key");
            parent.Nodes.Add(node);

            tok = scanner.Scan(TokenType.IDENTIFIER); // Terminal Rule: IDENTIFIER
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IDENTIFIER) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Key

        private void ParseVariablesDefinitions(ParseNode parent) // NonTerminalSymbol: VariablesDefinitions
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.VariablesDefinitions), "VariablesDefinitions");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.IDENTIFIER); // Terminal Rule: IDENTIFIER
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IDENTIFIER) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

             // Concat Rule
            tok = scanner.LookAhead(TokenType.SC); // ZeroOrMore Rule
            while (tok.Type == TokenType.SC)
            {

                 // Concat Rule
                tok = scanner.Scan(TokenType.SC); // Terminal Rule: SC
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.SC) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SC.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }

                 // Concat Rule
                tok = scanner.Scan(TokenType.IDENTIFIER); // Terminal Rule: IDENTIFIER
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.IDENTIFIER) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }
            tok = scanner.LookAhead(TokenType.SC); // ZeroOrMore Rule
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: VariablesDefinitions

        private void ParseParamsDefinitions(ParseNode parent) // NonTerminalSymbol: ParamsDefinitions
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ParamsDefinitions), "ParamsDefinitions");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.IDENTIFIER); // Terminal Rule: IDENTIFIER
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IDENTIFIER) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

             // Concat Rule
            tok = scanner.LookAhead(TokenType.SC); // ZeroOrMore Rule
            while (tok.Type == TokenType.SC)
            {

                 // Concat Rule
                tok = scanner.Scan(TokenType.SC); // Terminal Rule: SC
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.SC) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SC.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }

                 // Concat Rule
                tok = scanner.Scan(TokenType.IDENTIFIER); // Terminal Rule: IDENTIFIER
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.IDENTIFIER) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }
            tok = scanner.LookAhead(TokenType.SC); // ZeroOrMore Rule
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: ParamsDefinitions

        private void ParseParams(ParseNode parent) // NonTerminalSymbol: Params
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Params), "Params");
            parent.Nodes.Add(node);


             // Concat Rule
            ParseParam(node); // NonTerminal Rule: Param

             // Concat Rule
            tok = scanner.LookAhead(TokenType.SC); // ZeroOrMore Rule
            while (tok.Type == TokenType.SC)
            {

                 // Concat Rule
                tok = scanner.Scan(TokenType.SC); // Terminal Rule: SC
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.SC) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SC.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }

                 // Concat Rule
                ParseParam(node); // NonTerminal Rule: Param
            tok = scanner.LookAhead(TokenType.SC); // ZeroOrMore Rule
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Params

        private void ParseParam(ParseNode parent) // NonTerminalSymbol: Param
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Param), "Param");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.INTEGER, TokenType.DOUBLE, TokenType.STRING, TokenType.CF, TokenType.DOLDOT); // Choice Rule
            switch (tok.Type)
            { // Choice Rule
                case TokenType.INTEGER:
                    tok = scanner.Scan(TokenType.INTEGER); // Terminal Rule: INTEGER
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.INTEGER) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.INTEGER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.DOUBLE:
                    tok = scanner.Scan(TokenType.DOUBLE); // Terminal Rule: DOUBLE
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.DOUBLE) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DOUBLE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.STRING:
                    tok = scanner.Scan(TokenType.STRING); // Terminal Rule: STRING
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.STRING) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.STRING.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.CF:

                     // Concat Rule
                    tok = scanner.Scan(TokenType.CF); // Terminal Rule: CF
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.CF) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CF.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }

                     // Concat Rule
                    ParseFunction(node); // NonTerminal Rule: Function
                    break;
                case TokenType.DOLDOT:
                    do { // OneOrMore Rule
                        ParseHashAssignment(node); // NonTerminal Rule: HashAssignment
                        tok = scanner.LookAhead(TokenType.DOLDOT); // OneOrMore Rule
                    } while (tok.Type == TokenType.DOLDOT); // OneOrMore Rule
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            } // Choice Rule

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Param


    }

    #endregion Parser
}
